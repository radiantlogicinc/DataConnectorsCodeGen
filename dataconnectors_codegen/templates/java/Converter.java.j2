package {{ package_name }};

{% for imp in imports %}
import {{ imp }};
{% endfor %}

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.io.UnsupportedEncodingException;
import java.io.InputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.Map;

/**
 * Converts {{ input_type }} objects to {{ output_type }} objects.
 * Generated by DataConnectors CodeGen.
 */
@ManagedComponent
public class {{ class_name }} implements TypeConverter<{{ input_type }}, {{ output_type }}> {

    private static final Logger log = LoggerFactory.getLogger({{ class_name }}.class);

    // --- Injected or Initialized Mapping Data ---
    private final Map<String, Object> mappingData;
    {% if converter_type == 'request' %}
    private final Map<String, Map<String, Object>> clientMethodMetadata; // Added for request converter
    {% endif %}

    // Constructor or @PostConstruct to load mapping data
    public {{ class_name }}() {
        this.mappingData = loadMappingDataFromResource();
        {% if converter_type == 'request' %}
        this.clientMethodMetadata = loadClientMethodMetadata();
        {% endif %}
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> loadMappingDataFromResource() {
        String resourcePath = "/mapping_config.json"; // Path relative to classpath root
        log.info("Loading mapping configuration from resource: {}", resourcePath);
        try (InputStream is = getClass().getResourceAsStream(resourcePath)) {
            if (is == null) {
                log.error("Mapping configuration resource not found: {}", resourcePath);
                return Collections.emptyMap();
            }
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(is, Map.class);
        } catch (IOException e) {
            log.error("Failed to load or parse mapping configuration from resource: {}", resourcePath, e);
            return Collections.emptyMap();
        }
    }

    {% if converter_type == 'request' %}
    // Load client method metadata (passed as JSON)
    private Map<String, Map<String, Object>> loadClientMethodMetadata() {
        // Manually escape backslashes and double quotes for Java string literal
        String metadataJson = "{{ client_method_metadata_json | replace('\\', '\\\\') | replace('"', '\\"') }}";
        ObjectMapper mapper = new ObjectMapper();
        try {
            if (metadataJson == null || metadataJson.isEmpty() || metadataJson.equals("null")) {
                 log.error("Client method metadata JSON is null or empty in converter!");
                 return Collections.emptyMap();
            }
            TypeReference<Map<String, Map<String, Object>>> typeRef = new TypeReference<>() {};
            return mapper.readValue(metadataJson, typeRef);
        } catch (IOException e) {
            log.error("Failed to parse client method metadata JSON in converter: {}", e.getMessage(), e);
            return Collections.emptyMap();
        }
    }
    {% endif %}

    // Helper to safely get mapping details for an object class
    @SuppressWarnings("unchecked")
    private Map<String, Object> getObjectClassMapping(String ldapObjectClass) {
        Map<String, Object> objectClasses = (Map<String, Object>) mappingData.getOrDefault("object_classes", Collections.emptyMap());
        return (Map<String, Object>) objectClasses.get(ldapObjectClass);
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> getAttributeMapping(String ldapObjectClass, String ldapAttribute) {
         Map<String, Object> ocMapping = getObjectClassMapping(ldapObjectClass);
         if (ocMapping != null) {
             Map<String, Object> attributes = (Map<String, Object>) ocMapping.getOrDefault("attributes", Collections.emptyMap());
             // Handle list of attributes from mapping
             if (attributes instanceof List) {
                  for (Object attrObj : (List)attributes) {
                       if (attrObj instanceof Map) {
                            Map<String, Object> attrMap = (Map<String, Object>) attrObj;
                            if (ldapAttribute.equals(attrMap.get("ldapName"))) {
                                 return attrMap;
                            }
                       }
                  }
                  return null; // Not found in list
             } else if (attributes instanceof Map) {
                   // Handle old map format if necessary (though mapping schema uses list)
                   return (Map<String, Object>) attributes.get(ldapAttribute);
             } else {
                  return null;
             }
         }
         return null;
    }

    private String getApiQueryParamForLdapAttr(String oc, String ldapAttr) {
         Map<String, Object> attrMapping = getAttributeMapping(oc, ldapAttr);
         if (attrMapping != null) {
             return (String) attrMapping.getOrDefault("apiQueryParam", attrMapping.get("openApiPropertyName")); // Fallback to OpenAPI name
         }
         return null;
    }

    private String getOpenApiPropertyName(String oc, String ldapAttr) {
         Map<String, Object> attrMapping = getAttributeMapping(oc, ldapAttr);
         return (attrMapping != null) ? (String) attrMapping.get("openApiPropertyName") : null;
    }

    // Helper to find client method name based on path template and HTTP method
    // This now uses the injected metadata map.
    private String findClientMethod(String pathTemplate, String httpMethod) {
        if (pathTemplate == null || httpMethod == null) return null;

        // Iterate through the loaded metadata
        for (Map.Entry<String, Map<String, Object>> entry : clientMethodMetadata.entrySet()) {
            String operationId = entry.getKey(); // Key might be operationId
            Map<String, Object> meta = entry.getValue();
            String metaPath = (String) meta.get("pathTemplate");
            String metaMethod = (String) meta.get("httpMethod");

            if (pathTemplate.equals(metaPath) && httpMethod.equalsIgnoreCase(metaMethod)) {
                log.debug("Mapping path='{}', method='{}' to client method: {}", pathTemplate, httpMethod, meta.get("name"));
                return (String) meta.get("name"); // Return the Java method name
            }
        }
        log.warn("Could not find client method metadata for path='{}', method='{}'", pathTemplate, httpMethod);
        return null; // Not found
    }

    /**
     * Main conversion logic.
     */
    @Override
    public {{ output_type }} convert({{ input_type }} ldapRequest) {
        log.debug("Converting LdapRequest: {}", ldapRequest);

        {{ output_type }} backendRequest = new {{ output_type }}();

        try {
            if (ldapRequest instanceof SearchRequest) {
                handleSearchRequest((SearchRequest) ldapRequest, backendRequest);
            } else if (ldapRequest instanceof AddRequest) {
                handleAddRequest((AddRequest) ldapRequest, backendRequest);
            } else if (ldapRequest instanceof ModifyRequest) {
                handleModifyRequest((ModifyRequest) ldapRequest, backendRequest);
            } else if (ldapRequest instanceof DeleteRequest) {
                handleDeleteRequest((DeleteRequest) ldapRequest, backendRequest);
            } else {
                log.warn("Unsupported LdapRequest type: {}", ldapRequest.getClass().getName());
                throw new IllegalArgumentException("Unsupported LdapRequest type: " + ldapRequest.getClass().getName());
            }
        } catch (Exception e) {
            log.error("Failed to convert LdapRequest: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to convert LdapRequest", e);
        }

        return backendRequest;
    }

    {% if converter_type == 'request' %}

    // --- Request Type Handlers ---

    private void handleSearchRequest(SearchRequest searchRequest, {{ output_type }} backendRequest) {
        log.debug("Handling SearchRequest for base DN: {}, scope: {}, filter: {}",
                  searchRequest.getBaseDn(), searchRequest.getSearchScope(), searchRequest.getFilter());

        String targetOc = determineTargetObjectClass(searchRequest.getBaseDn(), searchRequest.getFilter());
        if (targetOc == null) {
             throw new IllegalArgumentException("Could not determine target object class for search request.");
        }
        backendRequest.setTargetObjectClass(targetOc);

        String pathTemplate = getPathTemplateForOc(targetOc);
        String clientMethodName = null;
        String httpMethod = "GET"; // Assume GET for search

        if (pathTemplate != null) {
            backendRequest.setPathTemplate(pathTemplate);
            // Determine specific client method based on scope
            if (searchRequest.getSearchScope() == SearchRequest.SearchScope.BASE) {
                 // Find method matching GET on the potentially specific resource path
                 clientMethodName = findClientMethod(pathTemplate, httpMethod);
            } else {
                 // Find method matching GET on the collection path (assume same template for now)
                 // TODO: Need mapping spec to differentiate collection path from item path if necessary
                 clientMethodName = findClientMethod(pathTemplate, httpMethod); // Needs adjustment if paths differ
            }

            if (clientMethodName == null) {
                 log.error("Could not find client method for {} {}", httpMethod, pathTemplate);
                 // Optionally throw exception here if dispatch is impossible
                 // throw new IllegalStateException("Cannot map search request to client method");
            }
            backendRequest.setTargetClientMethodName(clientMethodName); // ** Set the target method name **

        } else {
             log.error("Could not determine path template for OC '{}'", targetOc);
             // Optionally throw exception
             // throw new IllegalStateException("Cannot determine API path for search");
        }

        Map<String, String> queryParams = translateFilterToQueryParams(searchRequest.getFilter(), targetOc);
        backendRequest.setQueryParams(queryParams);

        List<String> requestedApiFields = mapLdapAttributesToApiFields(searchRequest.getAttributes(), targetOc);
        backendRequest.setFieldsToRetrieve(requestedApiFields);

        if (searchRequest.getSearchScope() == SearchRequest.SearchScope.BASE) {
            String entryId = extractIdFromDn(searchRequest.getBaseDn(), targetOc);
            if (entryId == null) {
                 throw new IllegalArgumentException("Could not extract entry ID from base DN for BASE scope search: " + searchRequest.getBaseDn());
            }
            backendRequest.setResourceId(entryId);
        } else {
             log.warn("ONELEVEL/SUBTREE search scope handling is basic; mapping to general list operation with filter.");
        }

        backendRequest.setHttpMethod(httpMethod);
        log.debug("Prepared BackendRequest for Search: {} -> Method '{}'", backendRequest, clientMethodName);
    }

    private void handleAddRequest(AddRequest addRequest, {{ output_type }} backendRequest) {
        log.debug("Handling AddRequest for DN: {}", addRequest.getDn());
        String targetOc = determineTargetObjectClass(addRequest.getDn(), null);
         if (targetOc == null) {
             throw new IllegalArgumentException("Could not determine target object class for add request.");
        }
        backendRequest.setTargetObjectClass(targetOc);

        String pathTemplate = getPathTemplateForOc(targetOc); // Assume path is for collection
        String httpMethod = "POST";
        String clientMethodName = null;

        if (pathTemplate != null) {
             // TODO: Adjust path template if creation endpoint differs from retrieval endpoint
            backendRequest.setPathTemplate(pathTemplate);
            clientMethodName = findClientMethod(pathTemplate, httpMethod);
            if (clientMethodName == null) {
                 log.error("Could not find client method for {} {}", httpMethod, pathTemplate);
            }
            backendRequest.setTargetClientMethodName(clientMethodName); // ** Set the target method name **
        } else {
             log.error("Could not determine path template for Add OC '{}'", targetOc);
        }

        Object requestPojo = mapAttributesToPojo(addRequest.getAttributes(), targetOc);
        backendRequest.setRequestBody(requestPojo);
        backendRequest.setHttpMethod(httpMethod);
        log.debug("Prepared BackendRequest for Add: {} -> Method '{}'", backendRequest, clientMethodName);
    }

    private void handleModifyRequest(ModifyRequest modifyRequest, {{ output_type }} backendRequest) {
        log.debug("Handling ModifyRequest for DN: {}", modifyRequest.getDn());
        String targetOc = determineTargetObjectClass(modifyRequest.getDn(), null);
        if (targetOc == null) {
             throw new IllegalArgumentException("Could not determine target object class for modify request.");
        }
        backendRequest.setTargetObjectClass(targetOc);

        String entryId = extractIdFromDn(modifyRequest.getDn(), targetOc);
        if (entryId == null) {
             throw new IllegalArgumentException("Could not extract entry ID from DN for modify request: " + modifyRequest.getDn());
        }
        backendRequest.setResourceId(entryId);

        String pathTemplate = getPathTemplateForOc(targetOc); // Path should include ID placeholder
        String httpMethod = "PATCH"; // Default to PATCH, PUT might need different handling/mapping
        String clientMethodName = null;

        if (pathTemplate != null) {
             backendRequest.setPathTemplate(pathTemplate);
             // TODO: Check mapping/OpenAPI for PUT vs PATCH preference
             clientMethodName = findClientMethod(pathTemplate, httpMethod);
             if (clientMethodName == null) {
                 // Try PUT if PATCH not found?
                 httpMethod = "PUT";
                 clientMethodName = findClientMethod(pathTemplate, httpMethod);
             }
             if (clientMethodName == null) {
                  log.error("Could not find client method for PATCH/PUT {}", pathTemplate);
             }
            backendRequest.setTargetClientMethodName(clientMethodName); // ** Set the target method name **
        } else {
             log.error("Could not determine path template for Modify OC '{}'", targetOc);
        }

        Object requestPojo = mapModificationsToPojo(modifyRequest.getModifications(), targetOc);
        backendRequest.setRequestBody(requestPojo);
        backendRequest.setHttpMethod(httpMethod);
        log.debug("Prepared BackendRequest for Modify: {} -> Method '{}'", backendRequest, clientMethodName);
    }

    private void handleDeleteRequest(DeleteRequest deleteRequest, {{ output_type }} backendRequest) {
        log.debug("Handling DeleteRequest for DN: {}", deleteRequest.getDn());
        String targetOc = determineTargetObjectClass(deleteRequest.getDn(), null);
         if (targetOc == null) {
             throw new IllegalArgumentException("Could not determine target object class for delete request.");
        }
        backendRequest.setTargetObjectClass(targetOc);

        String entryId = extractIdFromDn(deleteRequest.getDn(), targetOc);
        if (entryId == null) {
             throw new IllegalArgumentException("Could not extract entry ID from DN for delete request: " + deleteRequest.getDn());
        }
        backendRequest.setResourceId(entryId);

        String pathTemplate = getPathTemplateForOc(targetOc); // Path should include ID placeholder
        String httpMethod = "DELETE";
        String clientMethodName = null;

        if (pathTemplate != null) {
             backendRequest.setPathTemplate(pathTemplate);
             clientMethodName = findClientMethod(pathTemplate, httpMethod);
             if (clientMethodName == null) {
                  log.error("Could not find client method for {} {}", httpMethod, pathTemplate);
             }
            backendRequest.setTargetClientMethodName(clientMethodName); // ** Set the target method name **
        } else {
             log.error("Could not determine path template for Delete OC '{}'", targetOc);
        }

        backendRequest.setHttpMethod(httpMethod);
        log.debug("Prepared BackendRequest for Delete: {} -> Method '{}'", backendRequest, clientMethodName);
    }

    // --- Helper Methods for Request Conversion ---

    private String determineTargetObjectClass(DN baseDn, Filter filter) {
        // Basic implementation: Assumes objectClass is present in the DN or filter.
        // Needs enhancement based on mapping spec complexity.
        String ocFromDn = baseDn.getAttributeValue("objectClass"); // Check if OC is in RDN
        if (ocFromDn != null) return ocFromDn;

        // Try to extract from filter (e.g., (objectClass=inetOrgPerson))
        if (filter != null) {
            ExtractObjectClassVisitor visitor = new ExtractObjectClassVisitor();
            filter.accept(visitor);
            if (visitor.getObjectClass() != null) {
                return visitor.getObjectClass();
            }
        }

        // Fallback: Check mapping for a default or based on DN structure?
        // This part needs a clearer strategy based on how mapping is defined.
        Map<String, Object> dnStructure = (Map<String, Object>) mappingData.getOrDefault("dnStructure", Collections.emptyMap());
        // Example: If DN structure maps RDN attribute to an OC, use that?
        // String rdnAttr = (String) dnStructure.get("rdnAttribute");
        // if (rdnAttr != null && baseDn.getAttributeValue(rdnAttr) != null) { ... find OC based on RDN ... }

        // Last resort: if only one OC is defined in mapping, use that?
        Map<String, Object> objectClasses = (Map<String, Object>) mappingData.getOrDefault("object_classes", Collections.emptyMap());
        if (objectClasses.size() == 1) {
            return (String) objectClasses.keySet().iterator().next();
        }

        log.warn("Could not determine target object class from DN: {} or Filter: {}", baseDn, filter);
        return null;
    }

    private String getPathTemplateForOc(String ldapObjectClass) {
         Map<String, Object> ocMapping = getObjectClassMapping(ldapObjectClass);
         if (ocMapping != null) {
             return (String) ocMapping.get("apiEndpoint");
         }
         log.warn("No apiEndpoint defined in mapping for object class: {}", ldapObjectClass);
         return null;
    }

    private String extractIdFromDn(DN dn, String targetOc) {
        // Extract ID based on RDN attribute defined in mapping spec
        Map<String, Object> ocMapping = getObjectClassMapping(targetOc);
        String pkLdapAttr = (ocMapping != null) ? (String) ocMapping.get("primaryKeyLdapAttribute") : null;
        String pkParamName = (ocMapping != null) ? (String) ocMapping.get("primaryKeyOpenApiParameterName") : null;

        if (pkLdapAttr != null) {
             String rdnValue = dn.getAttributeValue(pkLdapAttr);
             if (rdnValue != null) return rdnValue;
        }

        // Fallback: Try RDN defined in global DN structure?
        Map<String, Object> dnStructure = (Map<String, Object>) mappingData.getOrDefault("dnStructure", Collections.emptyMap());
        String globalRdnAttr = (String) dnStructure.get("rdnAttribute");
        if (globalRdnAttr != null) {
             String rdnValue = dn.getAttributeValue(globalRdnAttr);
             if (rdnValue != null) return rdnValue;
        }

        // Last resort: If PK mapping uses parameter name, try finding that in DN?
        if (pkParamName != null) {
             String rdnValue = dn.getAttributeValue(pkParamName); // Less likely to be the RDN attr name
             if (rdnValue != null) return rdnValue;
        }

        log.warn("Could not extract ID from DN {} using mapping for OC {}", dn, targetOc);
        return null;
    }

    private List<String> mapLdapAttributesToApiFields(Set<String> ldapAttributes, String targetOc) {
        // Basic: If specific API fields are needed (e.g., ?fields=...), map them here.
        // For now, returning empty list assumes client fetches all default fields.
        return Collections.emptyList();
    }

    private Map<String, String> translateFilterToQueryParams(Filter filter, String targetOc) {
        if (filter == null) {
            return Collections.emptyMap();
        }
        ApiQueryParamVisitor visitor = new ApiQueryParamVisitor(this, targetOc);
        filter.accept(visitor);
        return visitor.getQueryParams();
    }

    /**
     * Maps JNDI Attributes to a generated POJO based on mapping spec.
     */
    private Object mapAttributesToPojo(Attributes ldapAttributes, String targetOc) {
        Map<String, Object> ocMapping = getObjectClassMapping(targetOc);
        if (ocMapping == null) {
            log.error("Cannot map attributes to POJO: No mapping found for OC '{}'", targetOc);
            return null;
        }
        String pojoClassName = (String) ocMapping.get("generatedPojoClassName");
        if (pojoClassName == null) {
            log.error("Cannot map attributes to POJO: No generatedPojoClassName defined for OC '{}'", targetOc);
            return null;
        }

        try {
            // Assumes POJO is in the model package
            Class<?> pojoClass = Class.forName(model_package + "." + pojoClassName);
            Object pojoInstance = pojoClass.getDeclaredConstructor().newInstance();

            List<Map<String, Object>> attributeMappings = (List<Map<String, Object>>) ocMapping.getOrDefault("attributes", Collections.emptyList());

            for (Map<String, Object> attrMapping : attributeMappings) {
                String ldapAttrName = (String) attrMapping.get("ldapName");
                String openApiPropName = (String) attrMapping.get("openApiPropertyName"); // Use the target POJO field name
                String setterName = (String) attrMapping.get("setterName"); // Pre-calculated setter name

                if (ldapAttrName == null || openApiPropName == null || setterName == null) continue;

                Attribute ldapAttr = ldapAttributes.get(ldapAttrName);
                if (ldapAttr != null && ldapAttr.size() > 0) {
                    try {
                        Object value = ldapAttr.get(); // Get first value for simplicity
                        // Find setter method (pre-calculated name)
                        Method setter = findSetter(pojoClass, setterName, value); // Find based on value type if possible

                        if (setter != null) {
                            // Convert value if necessary
                            Object convertedValue = convertValueToType(value, setter.getParameterTypes()[0]);
                            setter.invoke(pojoInstance, convertedValue);
                        } else {
                             log.warn("Could not find suitable setter '{}' on class {} for attribute '{}'", setterName, pojoClassName, ldapAttrName);
                        }
                    } catch (NamingException | IllegalAccessException | InvocationTargetException e) {
                        log.error("Error processing LDAP attribute '{}' for POJO mapping: {}", ldapAttrName, e.getMessage(), e);
                    }
                }
            }
            return pojoInstance;
        } catch (Exception e) {
            log.error("Failed to instantiate or populate POJO {}: {}", pojoClassName, e.getMessage(), e);
            return null;
        }
    }

    /**
     * Maps JNDI Modifications to a generated POJO (for PATCH/PUT).
     * Creates a POJO containing only the modified fields.
     */
    private Object mapModificationsToPojo(List<ModificationItem> modifications, String targetOc) {
         Map<String, Object> ocMapping = getObjectClassMapping(targetOc);
         if (ocMapping == null) {
             log.error("Cannot map modifications to POJO: No mapping found for OC '{}'", targetOc);
             return null;
         }
         String pojoClassName = (String) ocMapping.get("generatedPojoClassName");
         if (pojoClassName == null) {
             log.error("Cannot map modifications to POJO: No generatedPojoClassName defined for OC '{}'", targetOc);
             return null;
         }

         try {
             Class<?> pojoClass = Class.forName(model_package + "." + pojoClassName);
             Object pojoInstance = pojoClass.getDeclaredConstructor().newInstance();

             for (ModificationItem item : modifications) {
                 String ldapAttrName = item.getAttribute().getID();
                 Map<String, Object> attrMapping = getAttributeMapping(targetOc, ldapAttrName);

                 if (attrMapping != null) {
                      String openApiPropName = (String) attrMapping.get("openApiPropertyName");
                      String setterName = (String) attrMapping.get("setterName");

                      if (openApiPropName != null && setterName != null) {
                          Attribute ldapAttr = item.getAttribute();
                          if (ldapAttr != null && ldapAttr.size() > 0) {
                              // For REPLACE or ADD, set the value. For REMOVE, potentially set to null if supported.
                              Object value = (item.getModificationOp() == DirContext.REMOVE_ATTRIBUTE) ? null : ldapAttr.get();

                              try {
                                  Method setter = findSetter(pojoClass, setterName, value);
                                  if (setter != null) {
                                       Object convertedValue = convertValueToType(value, setter.getParameterTypes()[0]);
                                       setter.invoke(pojoInstance, convertedValue);
                                  } else {
                                       log.warn("Could not find suitable setter '{}' on class {} for modification attribute '{}'", setterName, pojoClassName, ldapAttrName);
                                  }
                              } catch (IllegalAccessException | InvocationTargetException e) {
                                   log.error("Error applying modification for LDAP attribute '{}': {}", ldapAttrName, e.getMessage());
                              }
                          } else if (item.getModificationOp() == DirContext.REMOVE_ATTRIBUTE) {
                               // Handle removal of attribute by setting field to null
                               try {
                                    Method setter = findSetter(pojoClass, setterName, null);
                                    if (setter != null) {
                                         setter.invoke(pojoInstance, (Object) null);
                                    }
                               } catch (IllegalAccessException | InvocationTargetException e) {
                                    log.error("Error setting field to null for removed LDAP attribute '{}': {}", ldapAttrName, e.getMessage());
                               }
                          }
                      }
                 }
             }
             return pojoInstance;
         } catch (Exception e) {
             log.error("Failed to instantiate or populate POJO {} from modifications: {}", pojoClassName, e.getMessage(), e);
             return null;
         }
    }

    /** Helper to find setter method, potentially adapting for type */
    private Method findSetter(Class<?> pojoClass, String setterName, Object value) {
         // Try exact match first
         try {
             Class<?> valueType = (value != null) ? value.getClass() : null;
             // Basic type matching, needs refinement for primitives vs wrappers, collections etc.
             for (Method method : pojoClass.getMethods()) {
                  if (method.getName().equals(setterName) && method.getParameterCount() == 1) {
                       // Found setter by name, check if param type is compatible
                       Class<?> paramType = method.getParameterTypes()[0];
                       if (value == null || paramType.isAssignableFrom(valueType)) {
                            return method; // Direct match or superclass
                       }
                       // Add specific checks for primitive/wrapper compatibility if needed
                       if (paramType == int.class && valueType == Integer.class) return method;
                       if (paramType == long.class && valueType == Long.class) return method;
                       // ... other primitive/wrapper pairs ...
                       if (paramType == Integer.class && valueType == int.class) return method;
                       // Check if value can be converted (e.g., Integer to Long)
                       if (paramType == Long.class && valueType == Integer.class) return method;
                       if (paramType == Double.class && (valueType == Float.class || valueType == Integer.class || valueType == Long.class)) return method;
                       if (paramType == BigDecimal.class && (valueType == Integer.class || valueType == Long.class || valueType == Double.class || valueType == Float.class )) return method;
                       // Add more lenient conversions if required
                  }
             }
             // Fallback: Find first setter with the correct name if type matching failed
             for (Method method : pojoClass.getMethods()) {
                  if (method.getName().equals(setterName) && method.getParameterCount() == 1) {
                       log.trace("Found setter {} by name, using despite potential type mismatch.", setterName);
                       return method;
                  }
             }
         } catch (Exception e) {
              log.warn("Reflection error finding setter '{}' on {}: {}", setterName, pojoClass.getSimpleName(), e.getMessage());
         }
         return null;
    }

    /** Basic value conversion */
    private Object convertValueToType(Object value, Class<?> targetType) {
         if (value == null) return null;
         if (targetType.isAssignableFrom(value.getClass())) return value;

         try {
              String strValue = value.toString();
              if (targetType == String.class) return strValue;
              if (targetType == Integer.class || targetType == int.class) return Integer.parseInt(strValue);
              if (targetType == Long.class || targetType == long.class) return Long.parseLong(strValue);
              if (targetType == Double.class || targetType == double.class) return Double.parseDouble(strValue);
              if (targetType == Float.class || targetType == float.class) return Float.parseFloat(strValue);
              if (targetType == Boolean.class || targetType == boolean.class) return Boolean.parseBoolean(strValue);
              if (targetType == BigDecimal.class) return new BigDecimal(strValue);
              if (targetType == LocalDate.class) return LocalDate.parse(strValue); // Assumes ISO_DATE
              if (targetType == OffsetDateTime.class) return OffsetDateTime.parse(strValue); // Assumes ISO_OFFSET_DATE_TIME
              // Add other conversions if needed (e.g., byte[], collections)
         } catch (NumberFormatException | DateTimeParseException e) {
              log.warn("Could not convert value '{}' to type {}: {}", value, targetType.getSimpleName(), e.getMessage());
              // Return original value or null? Or throw?
              return value; // Return original as fallback
         }

         log.warn("Unsupported target type for conversion: {}", targetType.getSimpleName());
         return value; // Fallback
    }

    // --- Filter Visitor for Query Param Translation ---
    private static class ApiQueryParamVisitor implements FilterVisitor {
        private final StringBuilder queryBuilder = new StringBuilder();
        private final Map<String, String> queryParams = new HashMap<>();
        private final LdapToBackendRequestConverter parentConverter;
        private final String targetOc;
        private boolean firstCondition = true;

        public ApiQueryParamVisitor(LdapToBackendRequestConverter converter, String targetOc) {
            this.parentConverter = converter;
            this.targetOc = targetOc;
        }

        public Map<String, String> getQueryParams() {
            // Final assembly of query string might happen here or return map
            return queryParams;
        }

        @Override
        public void visitAnd(Filter filter) {
            visitLogicOperator(filter, " AND ");
        }

        @Override
        public void visitOr(Filter filter) {
            visitLogicOperator(filter, " OR ");
        }

        @Override
        public void visitNot(Filter filter) {
             // How APIs handle NOT varies widely. Placeholder.
             log.warn("Filter translation for NOT operator is not fully supported.");
            queryBuilder.append("NOT (");
            filter.getChildren().get(0).accept(this);
            queryBuilder.append(")");
        }

        private void visitLogicOperator(Filter filter, String operator) {
             // Simple parenthesis grouping for now
            queryBuilder.append("(");
            boolean first = true;
            for (Filter child : filter.getChildren()) {
                if (!first) {
                    queryBuilder.append(operator);
                }
                child.accept(this);
                first = false;
            }
            queryBuilder.append(")");
        }

        @Override
        public void visitEquality(Filter filter) {
            handleSimpleFilter(filter, "=");
        }

        @Override
        public void visitGreaterOrEqual(Filter filter) {
            handleSimpleFilter(filter, ">=");
        }

        @Override
        public void visitLessOrEqual(Filter filter) {
            handleSimpleFilter(filter, "<=");
        }

        @Override
        public void visitPresence(Filter filter) {
             // API equivalent depends: ?attr=* or ?hasAttr=true
             log.warn("Filter translation for PRESENCE operator is basic.");
             String ldapAttr = filter.getAttributeName();
             String apiQueryParam = parentConverter.getApiQueryParamForLdapAttr(targetOc, ldapAttr);
             if (apiQueryParam != null) {
                 queryParams.put(apiQueryParam + "_exists", "true"); // Example param name
                 // queryBuilder.append(encode(apiQueryParam)).append(" IS NOT NULL");
             } else {
                  log.warn("No API query param mapping found for LDAP attribute '{}' in presence filter.", ldapAttr);
             }
        }

        @Override
        public void visitApproximateMatch(Filter filter) {
             log.warn("Filter translation for APPROXIMATE MATCH operator is not supported, treating as equality.");
             handleSimpleFilter(filter, "=");
        }

        @Override
        public void visitExtensibleMatch(Filter filter) {
             log.warn("Filter translation for EXTENSIBLE MATCH operator is not supported.");
             // queryBuilder.append("FALSE");
        }

        @Override
        public void visitSubstring(Filter filter) {
            // API equivalent varies: ?attr=*val*, ?attr_contains=val, ?attr_startswith=val
             log.warn("Filter translation for SUBSTRING operator is basic (contains).");
             String ldapAttr = filter.getAttributeName();
             String apiQueryParam = parentConverter.getApiQueryParamForLdapAttr(targetOc, ldapAttr);
             String value = filter.getInitialSubstring() + "*" + filter.getFinalSubstring(); // Simplistic wildcard
             value = value.replace("**", "*"); // Clean up adjacent wildcards

             if (apiQueryParam != null) {
                 queryParams.put(apiQueryParam + "_contains", value); // Example param name
                 // queryBuilder.append(encode(apiQueryParam)).append(" LIKE ").append(encodeValue(value));
             } else {
                  log.warn("No API query param mapping found for LDAP attribute '{}' in substring filter.", ldapAttr);
             }
        }

        private void handleSimpleFilter(Filter filter, String operator) {
            String ldapAttr = filter.getAttributeName();
            // Special handling for objectClass=
            if ("objectClass".equalsIgnoreCase(ldapAttr)) {
                 // Usually handled by determining the target endpoint, not a query param
                 log.debug("Ignoring objectClass filter for query parameter translation.");
                 return;
            }

            String apiQueryParam = parentConverter.getApiQueryParamForLdapAttr(targetOc, ldapAttr);
            if (apiQueryParam != null) {
                String value = filter.getAttributeValue().toString();
                // TODO: Add operator suffix if API uses it (e.g., _eq, _gte)
                String paramKey = apiQueryParam; // Basic mapping
                if (!"=".equals(operator)) {
                     // Example: Add suffix based on operator if API uses conventions like _gte, _lte
                     // paramKey = apiQueryParam + mapOperatorToSuffix(operator);
                     log.warn("Operator '{}' for param '{}' might not be translated correctly to API query.", operator, apiQueryParam);
                }
                queryParams.put(paramKey, value); // Simple key=value for now
                // queryBuilder.append(encode(apiQueryParam)).append(operator).append(encodeValue(value));
            } else {
                log.warn("No API query param mapping found for LDAP attribute '{}' in filter: {}", ldapAttr, filter);
            }
        }

        private String encode(String value) {
             if (value == null) return "";
             try {
                  return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
             } catch (UnsupportedEncodingException e) {
                   return value; // Should not happen with UTF-8
             }
        }
    }

     // --- Visitor to extract objectClass from filter ---
     private static class ExtractObjectClassVisitor implements FilterVisitor {
         private String objectClass = null;

         public String getObjectClass() {
             return objectClass;
         }

         @Override
         public void visitEquality(Filter filter) {
             if ("objectClass".equalsIgnoreCase(filter.getAttributeName()) && objectClass == null) {
                 objectClass = filter.getAttributeValue().toString();
             }
         }
         // Implement other visit methods to potentially traverse AND/OR
         @Override public void visitAnd(Filter filter) { filter.getChildren().forEach(c -> c.accept(this)); }
         @Override public void visitOr(Filter filter) { filter.getChildren().forEach(c -> c.accept(this)); }
         @Override public void visitNot(Filter filter) { filter.getChildren().forEach(c -> c.accept(this)); }
         // Ignore other filter types for OC extraction
         @Override public void visitGreaterOrEqual(Filter filter) {}
         @Override public void visitLessOrEqual(Filter filter) {}
         @Override public void visitPresence(Filter filter) {}
         @Override public void visitApproximateMatch(Filter filter) {}
         @Override public void visitExtensibleMatch(Filter filter) {}
         @Override public void visitSubstring(Filter filter) {}
     }

    {% endif %}

    {% if converter_type == 'response' %}

    // This converter might need multiple methods depending on the expected output
    // type (e.g., SearchResultEntry vs ResponseEntity<?>)

    // --- Response Conversion Methods ---

    /**
     * Main conversion logic for responses. Determines if the input BackendResponse
     * should be converted to a List<SearchResultEntry> or a single ResponseEntity.
     *
     * @param backendResponse The response from the backend client.
     * @return Either a List<SearchResultEntry> or a ResponseEntity<?>, or null on error.
     */
    @Override
    public Object convert(BackendResponse backendResponse) {
        if (backendResponse == null) {
             log.warn("Input BackendResponse is null, cannot convert.");
             return null; // Or return an error ResponseEntity?
        }

        Object payload = backendResponse.getPayload();
        int statusCode = backendResponse.getStatusCode();

        // If payload is a Collection, assume it's a list result from search/list operation
        if (payload instanceof Collection) {
            log.debug("BackendResponse payload is a Collection, converting to List<SearchResultEntry>.");
            List<SearchResultEntry> results = new ArrayList<>();
            for (Object item : (Collection<?>) payload) {
                // Assume each item can be converted to a SearchResultEntry
                BackendResponse singleItemResponse = new BackendResponse();
                singleItemResponse.setPayload(item);
                singleItemResponse.setStatusCode(statusCode); // Carry over status if needed?
                SearchResultEntry entry = convertToSearchResultEntry(singleItemResponse);
                if (entry != null) {
                     results.add(entry);
                }
            }
            return results;
        } else if (payload != null) {
             // Payload is not null and not a collection, assume it's a single resource
             // Convert to SearchResultEntry if it looks like a successful GET response (200 OK)
             // Otherwise, wrap in ResponseEntity for POST/PUT/PATCH/DELETE results.
             if (statusCode >= 200 && statusCode < 300 && backendResponse.isLikelyGETResponse()) { // Need to determine if it was GET
                  log.debug("BackendResponse payload is a single object (status {}), converting to SearchResultEntry.", statusCode);
                  return convertToSearchResultEntry(backendResponse);
             } else {
                  log.debug("BackendResponse payload is a single object (status {}), converting to ResponseEntity.", statusCode);
                  return convertToResponseEntity(backendResponse);
             }
        } else {
             // Payload is null. Treat as a simple success/failure response (e.g., for DELETE 204).
             log.debug("BackendResponse payload is null (status {}), converting to ResponseEntity.", statusCode);
             return convertToResponseEntity(backendResponse);
        }
    }

    /**
     * Converts a backend response object into an Ldap SearchResultEntry.
     * Typically used for search results (single entry).
     *
     * @param backendResponse The response object from the backend client containing a single payload item.
     * @return A SearchResultEntry representing one LDAP entry, or null if conversion fails.
     */
    public SearchResultEntry convertToSearchResultEntry(BackendResponse backendResponse) {
        if (backendResponse == null) return null;

        Object payload = backendResponse.getPayload();
        log.debug("Converting BackendResponse payload ({}) to SearchResultEntry", payload != null ? payload.getClass().getSimpleName() : "null");
        if (payload == null) {
            log.warn("BackendResponse payload is null, cannot create SearchResultEntry.");
            return null;
        }

        String ldapObjectClass = determineLdapObjectClass(payload);
        if (ldapObjectClass == null) {
             log.error("Could not determine LDAP object class for backend payload: {}", payload.getClass().getName());
             return null;
        }
        Map<String, Object> ocMapping = getObjectClassMapping(ldapObjectClass);
         if (ocMapping == null) {
             log.error("No mapping found for determined object class '{}'", ldapObjectClass);
             return null;
        }

        DN entryDn = constructDn(payload, ocMapping);
        Attributes ldapAttributes = mapBackendResponseToAttributes(payload, ldapObjectClass, ocMapping);

        if (entryDn == null || ldapAttributes == null) {
             log.error("Could not construct DN or attributes for backend payload (ObjectClass: {}): {}", ldapObjectClass, payload);
             return null;
        }

        return new SearchResultEntry(entryDn, ldapAttributes);
    }

    /**
     * Converts a backend response object into a generic ResponseEntity.
     * Used for non-search operations (create, modify, delete) or errors.
     *
     * @param backendResponse The response object from the backend client.
     * @return A ResponseEntity indicating the operation status and potentially including payload.
     */
     public ResponseEntity<?> convertToResponseEntity(BackendResponse backendResponse) {
         log.debug("Converting BackendResponse (status: {}) to ResponseEntity", backendResponse != null ? backendResponse.getStatusCode() : "null");

         ResponseStatus status = mapHttpStatusCodeToResponseStatus(backendResponse != null ? backendResponse.getStatusCode() : 500);
         Object data = (backendResponse != null) ? backendResponse.getPayload() : null;

         // Optionally wrap payload in BackendResponse if needed downstream, or pass raw payload?
         // Passing raw payload for now.
         return new ResponseEntity<>(status, data);
     }

    // --- Helper Methods for Response Conversion ---

    private ResponseStatus mapHttpStatusCodeToResponseStatus(int statusCode) {
        if (statusCode >= 200 && statusCode < 300) {
             return ResponseStatus.SUCCESS;
        } else if (statusCode == 400) {
             return ResponseStatus.FAILURE_INVALID_REQUEST;
        } else if (statusCode == 401 || statusCode == 403) {
             return ResponseStatus.FAILURE_AUTHENTICATION; // Or FAILURE_AUTHORIZATION
        } else if (statusCode == 404) {
             return ResponseStatus.FAILURE_NOT_FOUND;
        } else if (statusCode == 409) {
             return ResponseStatus.FAILURE_ALREADY_EXISTS;
        } else if (statusCode == 429) {
             return ResponseStatus.FAILURE_RATE_LIMIT; // Needs specific SDK status?
        } else if (statusCode >= 500) {
             return ResponseStatus.FAILURE_BACKEND_ERROR;
        }
        // Default fallback
        log.warn("Unmapped HTTP status code {} encountered, returning FAILURE_OTHER.", statusCode);
        return ResponseStatus.FAILURE_OTHER;
    }


    private String determineLdapObjectClass(Object payload) {
        if (payload == null) return null;
        String payloadClassName = payload.getClass().getSimpleName();
        Map<String, Object> objectClasses = (Map<String, Object>) mappingData.getOrDefault("object_classes", Collections.emptyMap());

        for (Map.Entry<String, Object> entry : objectClasses.entrySet()) {
            Map<String, Object> ocMapping = (Map<String, Object>) entry.getValue();
            if (payloadClassName.equals(ocMapping.get("generatedPojoClassName"))) {
                 return entry.getKey(); // Return the mapping key (LDAP OC name)
            }
        }
        log.warn("Could not map payload class '{}' to a configured LDAP Object Class.", payloadClassName);
        return null;
    }

    private DN constructDn(Object payload, Map<String, Object> ocMapping) {
        String pkLdapAttr = (String) ocMapping.get("primaryKeyLdapAttribute");
        if (pkLdapAttr == null) {
            log.error("Cannot construct DN: primaryKeyLdapAttribute not defined in mapping for OC.");
            return null;
        }

        Map<String, Object> attrMappings = getAttributeMappingsMap(ocMapping); // Helper needed
        Map<String, Object> pkAttrMapping = (Map<String, Object>)attrMappings.get(pkLdapAttr);
        String pkGetterName = (pkAttrMapping != null) ? (String) pkAttrMapping.get("getterName") : null;

        if (pkGetterName == null) {
             log.error("Cannot construct DN: Could not determine getter method for primary key attribute '{}'.", pkLdapAttr);
             return null;
        }

        try {
            Method pkGetter = payload.getClass().getMethod(pkGetterName);
            Object pkValue = pkGetter.invoke(payload);
            if (pkValue == null) {
                log.error("Cannot construct DN: Primary key value obtained via {} is null.", pkGetterName);
                return null;
            }

            String rdnValue = pkValue.toString(); // Convert PK to string for DN
            // Use RDN attribute name from mapping if specified, otherwise use PK LDAP name
            String rdnAttrName = (String) ocMapping.getOrDefault("rdnAttribute", pkLdapAttr);

            Map<String, Object> dnStructure = (Map<String, Object>) mappingData.getOrDefault("dnStructure", Collections.emptyMap());
            String baseDnSuffix = (String) dnStructure.get("baseDnSuffix");
            if (baseDnSuffix == null) {
                 log.error("Cannot construct DN: baseDnSuffix is missing in mapping dnStructure.");
                 return null;
            }

            String rdn = rdnAttrName + "=" + DN.escapeValue(rdnValue);
            String fullDn = rdn + "," + baseDnSuffix;

            log.trace("Constructed DN: {}", fullDn);
            return new DN(fullDn);
        } catch (NoSuchMethodException e) {
             log.error("Cannot construct DN: Getter method '{}' not found on payload class {}: {}", pkGetterName, payload.getClass().getSimpleName(), e.getMessage());
        } catch (IllegalAccessException | InvocationTargetException e) {
             log.error("Cannot construct DN: Failed to invoke getter '{}' on payload: {}", pkGetterName, e.getMessage(), e);
        } catch (NamingException e) {
             log.error("Cannot construct DN: Invalid DN syntax '{}': {}", pkLdapAttr + "=" + "...?" + "," + "...", e.getMessage());
        }
        return null;
    }

    private Attributes mapBackendResponseToAttributes(Object payload, String ldapObjectClass, Map<String, Object> ocMapping) {
        Attributes ldapAttributes = new BasicAttributes(true); // Case-insensitive
        List<Map<String, Object>> attributeMappings = (List<Map<String, Object>>) ocMapping.getOrDefault("attributes", Collections.emptyList());

        // Always add objectClass attribute
        Attribute ocAttr = new BasicAttribute("objectClass");
        ocAttr.add("top"); // Assume top is always needed
        ocAttr.add((String) ocMapping.get("ldapName")); // Add specific class name
        ldapAttributes.put(ocAttr);

        for (Map<String, Object> attrMapping : attributeMappings) {
             String ldapAttrName = (String) attrMapping.get("ldapName");
             String getterName = (String) attrMapping.get("getterName");
             if (ldapAttrName == null || getterName == null) continue;

             try {
                 Method getter = findGetter(payload.getClass(), getterName);
                 if (getter != null) {
                      Object value = getter.invoke(payload);
                      if (value != null) {
                           // Handle collections vs single values
                           Attribute basicAttr = new BasicAttribute(ldapAttrName);
                           if (value instanceof Collection) {
                                for (Object item : (Collection<?>) value) {
                                     if (item != null) basicAttr.add(item.toString()); // Convert items to string
                                }
                           } else {
                                basicAttr.add(value.toString()); // Convert single value to string
                           }
                           // Only add if attribute has values
                           if (basicAttr.size() > 0) {
                                ldapAttributes.put(basicAttr);
                           }
                      }
                 } else {
                     log.trace("Getter '{}' not found for attribute '{}' on payload class {}", getterName, ldapAttrName, payload.getClass().getSimpleName());
                 }
             } catch (Exception e) {
                  log.warn("Failed to get value for attribute '{}' using getter '{}': {}", ldapAttrName, getterName, e.getMessage());
             }
        }
        return ldapAttributes;
    }

    /** Helper to get attribute mappings as a map keyed by ldapName */
    private Map<String, Object> getAttributeMappingsMap(Map<String, Object> ocMapping) {
         Map<String, Object> map = new HashMap<>();
         List<Map<String, Object>> attributesList = (List<Map<String, Object>>) ocMapping.getOrDefault("attributes", Collections.emptyList());
         for (Map<String, Object> attrMapping : attributesList) {
              String ldapName = (String) attrMapping.get("ldapName");
              if (ldapName != null) {
                   map.put(ldapName, attrMapping);
              }
         }
         return map;
    }

    /** Helper to find getter method */
    private Method findGetter(Class<?> pojoClass, String getterName) {
         try {
              return pojoClass.getMethod(getterName);
         } catch (NoSuchMethodException e) {
              return null;
         }
    }

    {% endif %}

}
