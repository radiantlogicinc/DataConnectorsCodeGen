package {{ package_name }};

{% for imp in imports %}
import {{ imp }};
{% endfor %}

/**
 * HTTP Client for interacting with the {{ class_name.replace("Client", "") }} API.
 * Generated by DataConnectors CodeGen.
 */
@ManagedComponent
public class {{ class_name }} {

    private static final Logger log = LoggerFactory.getLogger({{ class_name }}.class);

    private final ObjectMapper objectMapper;
    private OkHttpClient httpClient;
    private String baseUrl;
    {% if auth_details.needs_api_key %}
    private String apiKey;
    private String apiKeyName = "{{ auth_details.api_key_name }}";
    private String apiKeyLocation = "{{ auth_details.api_key_in }}"; // "header" or "query"
    {% endif %}
    {% if auth_details.needs_http_basic %}
    private String basicAuthCredential;
    {% endif %}
    {% if auth_details.needs_bearer_token %}
    private String bearerToken;
    {% endif %}
    {% if auth_details.needs_oauth %}
    // TODO: Implement proper OAuth token storage and refresh mechanism
    private final AtomicReference<String> oauthAccessToken = new AtomicReference<>();
    {% endif %}

    private Map<String, String> connectionProps;

    // Configurable settings (could be injected via properties)
    private int connectTimeout = 30; // seconds
    private int readTimeout = 60;    // seconds
    private int writeTimeout = 30;   // seconds
    private int rateLimitMaxRetries = 3;
    private long rateLimitBaseDelayMs = 1000; // initial delay for exponential backoff

    @Inject
    public {{ class_name }}(ObjectMapper objectMapper) {
        // Inject ObjectMapper, could configure it further here if needed
        this.objectMapper = objectMapper.registerModule(new JavaTimeModule()); // Add Java 8 time support
    }

    @PostConstruct
    public void initialize() {
        log.info("Initializing {{ class_name }}...");
        this.baseUrl = connectionProps.getOrDefault("baseUrl", "");
        if (baseUrl == null || baseUrl.isEmpty()) {
            log.error("API Base URL is missing in connection properties!");
            throw new IllegalStateException("API Base URL (baseUrl) must be configured.");
        }
        // Ensure baseUrl ends with a slash for easier concatenation
        if (!baseUrl.endsWith("/")) {
            baseUrl += "/";
        }

        // Configure OkHttpClient (timeouts, etc.)
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(connectTimeout, TimeUnit.SECONDS)
            .writeTimeout(writeTimeout, TimeUnit.SECONDS)
            .readTimeout(readTimeout, TimeUnit.SECONDS)
            // TODO: Add interceptor for authentication
            .addInterceptor(this::authenticationInterceptor)
            .addInterceptor(this::errorHandlingInterceptor)
            .addInterceptor(this::rateLimitInterceptor)
            // Basic retry for transient network issues or potential rate limits (customize as needed)
            .retryOnConnectionFailure(true)
            .build();

        // Extract authentication credentials from properties
        {% if auth_details.needs_api_key %}
        this.apiKey = connectionProps.get("{{ auth_details.api_key_prop_name }}");
        if (apiKey == null || apiKey.isEmpty()) {
             log.warn("API Key ('{{ auth_details.api_key_prop_name }}') is configured in spec but missing in properties.");
             // Decide if this is fatal or optional based on API requirements
        }
        {% endif %}
        {% if auth_details.needs_http_basic %}
        String username = connectionProps.get("{{ auth_details.http_user_prop_name }}");
        String password = connectionProps.get("{{ auth_details.http_pass_prop_name }}");
        if (username != null && !username.isEmpty() && password != null) { // Password can be empty
            this.basicAuthCredential = Credentials.basic(username, password);
        } else {
            log.warn("HTTP Basic Auth credentials ('{{ auth_details.http_user_prop_name }}', '{{ auth_details.http_pass_prop_name }}') partially or fully missing.");
            // Decide if fatal or optional
        }
        {% endif %}
        {% if auth_details.needs_bearer_token %}
        this.bearerToken = connectionProps.get("{{ auth_details.bearer_token_prop_name }}");
         if (bearerToken == null || bearerToken.isEmpty()) {
             log.warn("Bearer Token ('{{ auth_details.bearer_token_prop_name }}') is configured in spec but missing in properties.");
             // Decide if fatal or optional
        }
        {% endif %}
        {% if auth_details.needs_oauth %}
        // TODO: Implement initial OAuth token retrieval logic if applicable (e.g., client credentials flow)
        log.warn("OAuth2 configured, but token retrieval/refresh logic is not implemented.");
        {% endif %}

        log.info("{{ class_name }} initialized successfully for base URL: {}", this.baseUrl);
    }

    @Inject
    public void setConnectionProps(@Properties(name = {{ connection_properties_enum }}) Map<String, String> props) {
        this.connectionProps = props;
    }

    // --- Authentication Interceptor ---
    private Response authenticationInterceptor(Interceptor.Chain chain) throws IOException {
        Request originalRequest = chain.request();
        Request.Builder builder = originalRequest.newBuilder();

        // Apply authentication based on configured method(s)
        // Priority can be adjusted if multiple methods are configured
        {% if auth_details.needs_api_key %}
        if (apiKey != null && !apiKey.isEmpty() && apiKeyLocation != null && apiKeyName != null) {
            if ("header".equalsIgnoreCase(apiKeyLocation)) {
                log.debug("Adding API Key to header: {}", apiKeyName);
                builder.header(apiKeyName, apiKey);
            } else if ("query".equalsIgnoreCase(apiKeyLocation)) {
                log.debug("Adding API Key to query parameter: {}", apiKeyName);
                HttpUrl url = originalRequest.url().newBuilder()
                                .addQueryParameter(apiKeyName, apiKey)
                                .build();
                builder.url(url);
            }
        }
        {% endif %}
        {% if auth_details.needs_http_basic %}
        if (basicAuthCredential != null) {
            log.debug("Adding HTTP Basic authentication header.");
            builder.header("Authorization", basicAuthCredential);
        }
        {% endif %}
        {% if auth_details.needs_bearer_token %}
        if (bearerToken != null && !bearerToken.isEmpty()) {
             log.debug("Adding Bearer token authentication header.");
             builder.header("Authorization", "Bearer " + bearerToken);
        }
        {% endif %}
        {% if auth_details.needs_oauth %}
        String currentToken = oauthAccessToken.get();
        if (currentToken != null && !currentToken.isEmpty()) {
            log.debug("Adding OAuth Bearer token authentication header.");
            builder.header("Authorization", "Bearer " + currentToken);
            // TODO: Add logic here or in response handling to refresh token if needed (e.g., on 401)
        }
        {% endif %}

        Request newRequest = builder.build();
        return chain.proceed(newRequest);
    }

    // --- Error Handling Interceptor ---
    private Response errorHandlingInterceptor(Interceptor.Chain chain) throws IOException {
        Request request = chain.request();
        Response response = chain.proceed(request);

        if (!response.isSuccessful()) {
            // Handle specific error codes or scenarios here if needed before general handling
            if (response.code() == 401) {
                 log.warn("Received 401 Unauthorized for request: {} {}", request.method(), request.url());
                 // TODO: Trigger OAuth token refresh logic here if applicable
                 // If refresh successful, potentially retry the request (complex)
            }
            // Other specific codes like 403 Forbidden, 429 Too Many Requests, 5xx Server Errors
            handleErrorResponse(response, request); // Call generic handler
            // Note: handleErrorResponse might throw an exception
        }

        return response;
    }

    // --- Rate Limiting Interceptor (Placeholder) ---
    private Response rateLimitInterceptor(Interceptor.Chain chain) throws IOException {
        Request request = chain.request();
        Response response = chain.proceed(request);

        int tryCount = 0;
        int maxTries = this.rateLimitMaxRetries;

        while (!response.isSuccessful() && response.code() == 429 && tryCount < maxTries) {
            tryCount++;
            long delayMillis = this.rateLimitBaseDelayMs * (long)Math.pow(2, tryCount -1); // Exponential backoff (base * 2^(n-1))

            // Check for Retry-After header
            String retryAfter = response.header("Retry-After");
            if (retryAfter != null) {
                try {
                    // Handle seconds or HTTP-date format
                    if (retryAfter.matches("^\\d+$")) {
                        delayMillis = Long.parseLong(retryAfter) * 1000;
                    } else {
                        // Parse HTTP date - complex, requires date parsing logic
                        // For simplicity, ignore date format for now
                         log.warn("Retry-After header has HTTP-date format, using default backoff.");
                    }
                } catch (NumberFormatException e) {
                    log.warn("Could not parse Retry-After header value '{}', using default backoff.", retryAfter);
                }
            }

            log.warn("Received 429 Too Many Requests. Retrying attempt {}/{} after {} ms for request: {} {}",
                     tryCount, maxTries, delayMillis, request.method(), request.url());

            // Close the previous response body before retry
            if (response.body() != null) {
                response.body().close();
            }

            try {
                Thread.sleep(delayMillis);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IOException("Thread interrupted during rate limit backoff", e);
            }

            // Retry the request
            response = chain.proceed(request);
        }

        return response;
    }

    // --- API Call Methods ---
    {% for method in methods %}
    /**
     * {{ method.summary }}
     * Corresponds to {{ method.http_method }} {{ method.endpoint_path_template }}
     {% for param in method.params -%}
     * @param {{ param.name }} {{ param.description }}
     {% endfor -%}
     * @return {{ method.return_type }}
     * @throws IOException If an error occurs during the API call.
     */
    public {{ return_type }} {{ method.name }}({% for param in method.params %}{{ param.type }} {{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %}) throws IOException {
        log.info("Executing {{ method.name }}(...)");

        {% set req_content_type = method.request_content_type or 'application/json' %}
        {% set resp_content_type = method.response_content_type or 'application/json' %}

        // 1. Construct URL
        String pathTemplate = "{{ method.endpoint_path_template }}";
        String path = pathTemplate;

        // Replace path parameters
        {% for param in method.path_params %}
        if ({{ param.name }} == null) {
            throw new IllegalArgumentException("Path parameter '{{ param.name }}' ({{ param.originalName }}) cannot be null for {{ method.name }}");
        }
        path = path.replace("{" + "{{ param.originalName }}" + "}", String.valueOf({{ param.name }}));
        {% endfor %}

        HttpUrl.Builder urlBuilder = Objects.requireNonNull(HttpUrl.parse(baseUrl + path.replaceAll("^/", ""))).newBuilder();

        // Add query parameters
        {% for param in method.query_params %}
        if ({{ param.name }} != null) {
            {% if param.fqnType.startswith("java.util.List") %}
            // Handle list query parameters (potentially requires specific formatting based on API)
            for (Object item : {{ param.name }}) {
                 if (item != null) {
                      urlBuilder.addQueryParameter("{{ param.originalName }}", String.valueOf(item));
                 }
            }
            {% else %}
            urlBuilder.addQueryParameter("{{ param.originalName }}", String.valueOf({{ param.name }}));
            {% endif %}
        } else if ({{ param.required }}) {
             log.warn("Required query parameter '{{ param.originalName }}' is null for {{ method.name }}.");
             // Depending on API behavior, might throw an error or proceed
        }
        {% endfor %}

        HttpUrl url = urlBuilder.build();
        log.debug("Request URL: {}", url);

        // 2. Prepare Request Body (if applicable)
        RequestBody okHttpRequestBody = null;
        {% if method.request_body_param %}
        if ({{ method.request_body_param.name }} != null) {
            try {
                String jsonBody = objectMapper.writeValueAsString({{ method.request_body_param.name }});
                okHttpRequestBody = RequestBody.create(jsonBody, MediaType.parse("application/json; charset=utf-8"));
                log.debug("Request Body ({}): {}", {{ method.request_body_param.name }}.getClass().getSimpleName(), jsonBody); // Avoid logging sensitive data in production
            } catch (com.fasterxml.jackson.core.JsonProcessingException e) {
                log.error("Failed to serialize request body for {{ method.name }}: {}", e.getMessage());
                throw new IOException("Failed to serialize request body", e);
            }
        } else if ({{ method.request_body_param.required }}){
             throw new IllegalArgumentException("Request body '{{ method.request_body_param.name }}' cannot be null for {{ method.name }}");
        } else if ("{{ req_content_type }}" == "application/x-www-form-urlencoded") {
             // Build form body from request object fields (assumes flat structure)
             FormBody.Builder formBuilder = new FormBody.Builder();
             try {
                 // Use introspection or a Map representation of the POJO
                 Map<String, Object> fields = objectMapper.convertValue({{ method.request_body_param.name }}, Map.class);
                 for (Map.Entry<String, Object> entry : fields.entrySet()) {
                     if (entry.getValue() != null) {
                         formBuilder.add(entry.getKey(), String.valueOf(entry.getValue()));
                     }
                 }
                 okHttpRequestBody = formBuilder.build();
             } catch (IllegalArgumentException e) {
                 log.error("Failed to convert request body POJO to Map for form encoding: {}", e.getMessage());
                 throw new IOException("Failed to encode form request body", e);
             }
        }
        {% else %}
        // For methods like POST/PUT that might expect an empty body sometimes
        if ("POST".equals("{{ method.http_method }}") || "PUT".equals("{{ method.http_method }}") || "PATCH".equals("{{ method.http_method }}")) {
             okHttpRequestBody = RequestBody.create("", null); // Empty body
        }
        {% endif %}

        // 3. Build Request
        Request.Builder requestBuilder = new Request.Builder()
            .url(url)
            .{{ method.http_method | lower }}(okHttpRequestBody);

        // Add headers (Accept, Content-Type, specific operation headers)
        requestBuilder.header("Accept", "{{ resp_content_type }}"); // Set based on expected response
        {% if method.request_body_param %}
        requestBuilder.header("Content-Type", "{{ req_content_type }}; charset=utf-8"); // Set based on request body type
        {% endif %}
        {% for param in method.header_params %}
        if ({{ param.name }} != null) {
             requestBuilder.header("{{ param.originalName }}", String.valueOf({{ param.name }}));
        } else if ({{ param.required }}) {
             log.warn("Required header parameter '{{ param.originalName }}' is null for {{ method.name }}.");
             // Depending on API behavior, might throw an error or proceed
        }
        {% endfor %}

        Request request = requestBuilder.build();

        // 4. Execute Request and Handle Response
        log.debug("Executing request: {} {}", request.method(), request.url());
        try (Response response = httpClient.newCall(request).execute()) {
            int statusCode = response.code();
            log.debug("Response Code: {}", statusCode);
            if (!response.isSuccessful()) {
                // Error handled by errorHandlingInterceptor, which might throw.
                // If it doesn't throw, we still shouldn't proceed normally.
                 // Rethrow or return a specific error object/status based on design.
                // The interceptor should have logged details.
                // Wrap the error status in BackendResponse if needed by caller, or just throw.
                throw new IOException("API call failed with code: " + statusCode + ". Check logs for details.");
            }

            // Handle response based on original expected type
            Object resultPayload = null;

            {% if method.original_return_type == "Void" %}
            log.debug("Request successful, original return type is Void.");
            // Consume body to close resources, even if not used
            if (response.body() != null) {
                 response.body().close();
            }
            resultPayload = null; // Payload is null for Void
            {% else %}
            // Handle responses with bodies
            if (response.body() == null) {
                 log.warn("Received successful response code {} but body is null for {{ method.name }}", statusCode);
                 // Decide return value based on API contract (e.g., null, empty Optional, throw error)
                 resultPayload = null; // Payload is null
            } else {
                 // 5. Process Successful Response Body
                 try (ResponseBody responseBody = response.body()) {
                     if (responseBody == null) {
                         resultPayload = null;
                     } else if ("{{ resp_content_type }}".startsWith("application/json")) {
                          if ({{ method.is_list_response }}) {
                              // Get the element type, removing List< >
                              String elementTypeName = "{{ method.original_return_type_fqn }}".replaceFirst("^java\\.util\\.List<(.+)>$", "$1");
                              Class<?> elementClass = Class.forName(elementTypeName);
                              CollectionType listType = objectMapper.getTypeFactory().constructCollectionType(List.class, elementClass);
                              resultPayload = objectMapper.readValue(responseBody.byteStream(), listType);
                          } else {
                              Class<?> responseClass = Class.forName("{{ method.original_return_type_fqn }}");
                              resultPayload = objectMapper.readValue(responseBody.byteStream(), responseClass);
                          }
                     } else if ("{{ resp_content_type }}".startsWith("text/plain")) {
                          // Handle plain text response
                          if ("String".equals("{{ method.original_return_type }}")) {
                              resultPayload = responseBody.string();
                          } else {
                               log.error("Cannot assign plain text response to expected type {}", "{{ method.original_return_type }}");
                               throw new IOException("Mismatched response type: Expected text/plain as String, got " + "{{ method.original_return_type }}");
                          }
                     } else {
                         // Handle other content types or throw error
                         log.error("Unsupported response content type: {}", "{{ resp_content_type }}");
                         throw new IOException("Unsupported response content type: " + "{{ resp_content_type }}");
                     }
                 } catch (ClassNotFoundException e) {
                      log.error("Could not find response class definition: {}", e.getMessage());
                      throw new IOException("Failed to find response class definition", e);
                 }
            }
            {% endif %}

            // Wrap the result payload and status code in BackendResponse
            BackendResponse backendResponse = new BackendResponse();
            backendResponse.setStatusCode(statusCode);
            backendResponse.setPayload(resultPayload);
            return backendResponse;

        } catch (IOException e) {
            log.error("IOException during API call for {{ method.name }} [{} {}]: {}", request.method(), request.url(), e.getMessage(), e);
            throw e; // Re-throw original IOException
        }
    }
    {% endfor %}

    // --- Error Handling Helper ---

    /**
     * Handles unsuccessful HTTP responses.
     *
     * @param response The failed OkHttp Response object.
     * @param request The original OkHttp Request object.
     * @throws IOException Can throw an exception to propagate the error.
     */
    private void handleErrorResponse(Response response, Request request) throws IOException {
        String errorBody = "<unavailable>";
        try {
            errorBody = response.body() != null ? response.body().string() : "<empty>";
            // Important: Consuming the body here prevents caller from reading it again.
        } catch (IOException e) {
            log.error("Error reading error response body for {} {}: {}",
                      request.method(), request.url(), e.getMessage());
        }

        log.error("API call [{}] {} failed with code {}: {}\nResponse Body: {}",
                  request.method(), request.url(), response.code(), response.message(), errorBody);

        // TODO: Implement more specific error mapping based on response.code()
        // Example: Map 404 to a specific exception or return status
        // Example: Map 429 to trigger backoff/retry logic (if not handled by OkHttp retry)
        // For now, throw a generic exception indicating the failure.
        throw new IOException(String.format("API Error: %d %s for %s %s",
                                response.code(),
                                response.message(),
                                request.method(),
                                request.url()));
    }

    // --- Test Connection Method --- 
    public boolean testConnection() {
         log.info("Attempting to test connection...");
         try {
             // Example: Make a simple GET request to the base URL or a known status endpoint
             Request request = new Request.Builder()
                 .url(baseUrl)
                 .get()
                 .build();
             try (Response response = httpClient.newCall(request).execute()) {
                 log.info("Test connection response code: {}", response.code());
                 // Consider success if status code is 2xx or maybe 401/403 (indicates server reachable)
                 return response.isSuccessful() || response.code() == 401 || response.code() == 403;
             }
         } catch (IOException e) {
             log.error("Test connection failed due to IOException: {}", e.getMessage());
             return false;
         }
    }

}
